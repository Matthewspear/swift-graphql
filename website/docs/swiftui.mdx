---
title: SwiftGraphQL ❤️ SwiftUI
sidebar_label: SwiftUI Basics
---

SwiftGraphQL's client is heavily based on Combine framework. Because Combine is neatly intertwined with SwiftUI, SwiftGraphQL comes with a set of easy to use utility classes and wrappers that let you run your queries. Depending on your selection you can choose between three property wrappers

- `@Query`,
- `@Mutation`, and
- `@Subscription`.

Lastly, you can use `@GraphQL` wrapper to access the client directly.

## Global Environment

Start by adding an environment wrapper around your app so you can access SwiftGraphQL client from anywhere in the app.

```swift
struct App: View {
	private var client = GraphQLClient.shared
		.withHeaders { headers in
			// auth
		}

	var body: some View {
		GraphQLContainer(client: client) {
			// Your app...
		}
	}
}
```

## Wrappers

### Queries

You may access fetch queries by wrapping a property with a `@Query` wrapper. It accepts a query selection object and cache specification as a parameter and returns a hanndful of functions that you may call to manually fetch, reload and read the data.

```swift
struct HumanView: View {

	@Query(selection: [Character].query) var characters: QueryResult<[Character]>
	@Query(selection: Human.query, cache: .cacheAndNetwork) var human: QueryResult<Human>

	var body: some View {
		VStack {
			if human.loading {
				ActivityIndicator()
			}

			if let data = human.data {
				VStack {
					Text(data.name)
						.bold()
					Text(data.description)
				}
			}

			if let error = human.error {
				Text(error.message)
			}
		}
	}
}
```

### Mutations

Mutations resemble the structure of the queries but are fundamentally different in where you specify the query. Unlike queries that have a set query, you can use any selection that results in the type specified in the `@Mutation` wrapper.

```swift
struct ProjectView: View {
	@Mutation private var mutation: MutationResult<Project>

	var id: String

	var body: some View {
		Button(action: {
			mutation.mutate(selection: Project.star(id: ~id))
		}) {
			Text("Star")
		}
	}
}
```

### Subscriptions

Subscriptions resemble queries. They accept a selection parameter, but don't have a `cache` parameter. Your view auto refreshes whenever new data arrives.

```swift
struct ChatView: View {
	@Subscription(selection: [Chat].subscription(id: ~id)) var messages: SubscriptionResult<[Message]>

	/// Id of the channel.
	var id: String

	var body: some View {
		VStack {
			ForEach(messages) { message in
				HStack {
					AsyncImage(url: message.sender.avatar)
					Text(message.message)
				}
			}
		}
	}
}
```
