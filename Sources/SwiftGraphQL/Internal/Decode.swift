import Foundation

/// Represents a collection of decoded values identifieable by their hashes.
///
/// SwiftGraphQL primarily relies on the autogenerated Encodable & Decodable
/// protocols that Swift provides for all basic types and compositions.
///
/// We use HashMap to represent a dictionary of aliases internally. Aliases
/// are a way for GraphQL to query the same field with different parameters.
///
/// HashMap assumes that values with the same key are of the same type. Since
/// we rely on code generation, we can confidently assert that casts inside
/// `subscript` function will work.
///
public struct HashMap {
    private var data = [Key: Any]()

    public init() {}

    private struct Key: Hashable {
        let key: String
        let hash: String
    }

    // MARK: - Accessors

    /// Sets the scalar to specific index.
    public mutating func set(key: String, hash: String, value: Any) {
        let index = Key(key: key, hash: hash)
        data[index] = value
    }

    /// Returns a dictionary of values for a specified key.
    public subscript<Value>(keyed: String) -> [String: Value] {
        var map = [String: Value]()

        data.forEach {
            let (key, value) = $0

            // Filter out the types with a different key and cast down.
            if key.key == keyed {
                map[key.hash] = (value as! Value)
            }
        }

        return map
    }
}

/*
 We use DynamicCodingKeys to allow response decoder to look up
 for arbitrary key in the response. Otherwise, we would have to
 hardcode field alias which is impossible because of aliasing.
 */

public struct DynamicCodingKeys: CodingKey {
    // Use for string-keyed dictionary
    public var stringValue: String
    public init?(stringValue: String) {
        self.stringValue = stringValue
    }

    // Use for integer-keyed dictionary
    public var intValue: Int?
    public init?(intValue _: Int) { nil }
}
