import Foundation
import GraphQLAST


/// Structure protocol outlines anything that might be made codable (e.g. GraphQL Objects, Interfaces and Unions).
///
/// To decode a response we first decode values to an intermediate type. We first decode the key
/// that references a result and use the  engraved in the alias to further decode the result. The result is
/// saved into a HashMap structure that groups fields with the same type.
protocol Structure {
    
    /// Name of the GraphQL type that corresponds to this structure
    var name: String { get }
    
    /// Fields that are shared between all types in the structure.
    var fields: [Field] { get }
    
    /// References to the type those fields may be part of.
    var possibleTypes: [ObjectTypeRef] { get }
}

extension Structure {
    
    /// Returns a list of fields that appear in the structure differentiated
    /// by the type they appear in.
    ///
    ///  - parameter parent: Parent type containing already included values.
    ///  - parameter objects: List of all types that appear in the schema.
    func fieldsByType(
        parent: String,
        objects: [ObjectType],
        context: Context
    ) -> [(field: Field, parent: String)] {
        var union: [(field: Field, parent: String)] = []
        
        for field in self.fields {
            union.append((field: field, parent: parent))
        }

        for object in objects {
            // Skip object if it's not inside possible types.
            guard possibleTypes.contains(where: { $0.name == object.name }) else {
                continue
            }
            
            for field in object.fields + self.fields {
                // Skip shared fields.
                if union.contains(where: {
                    $0.field.name == field.name && $0.parent == object.name
                }) {
                    continue
                }
                union.append((field: field, parent: object.name))
            }
        }

        return union
    }
}

extension Structure {
    
    /// Returns a definition of a Swift struct that represents a given GraphQL structure.
    ///
    /// - parameter name: The name that the structure should use in the API (not necessarily the same as its GraphQL name).
    /// - parameter objects: List of all objects that appear in the schema.
    func definition(name apiName: String, objects: [ObjectType], context: Context) throws -> String {
        let typename: String
        if let object = possibleTypes.first, self.possibleTypes.count == 1 {
            typename = "let __typename: TypeName = .\(object.name.camelCase)"
        } else {
            typename = "let __typename: TypeName"
        }

        let properties = try self.fieldsByType(parent: self.name, objects: objects, context: context)
            .sorted(by: { $0.field.name < $1.field.name })
            .map { try $0.field.declaration(parent: $0.parent, context: context) }
            .lines
        
        let typenamesEnum = possibleTypes.typenamesEnum()

        return """
        struct \(apiName) {
            \(typename)
            \(properties)

            \(typenamesEnum)
        }
        """
    }
}

private extension Field {
    
    /// Return a field variable declaration in the structure.
    func declaration(parent: String, context: Context) throws -> String {
        let type = try self.type.namedType.type(scalars: context.scalars)
        let wrappedType = self.type.nonNullable.type(for: type)
        let alias = "\(name.camelCase)\(parent.camelCase)"

        return "let \(alias.normalize): [String: \(wrappedType)]"
    }
}

// MARK: - Decoder

extension Collection where Element == (field: Field, parent: String) {
    
    /// Returns a function definition for decoder of the fields.
    ///
    /// - parameter parent: Type that holds values of the decoders.
    /// - parameter includeTypeNameDecoder: Tells whether the decoder should contain extra code for decoding typenames of the returned values.
    func decoders(includeTypenameDecoder: Bool = false, context: Context) throws -> String {
        let decoders: String = try self
            .map { try $0.field.decoder(parent: $0.parent, context: context) }
            .joined(separator: "\n")
        
        // Mappings extract decoded values from HashMaps.
        // We use field aliases to correctly bind returned values to their fields.
        //
        // NOTE: Field alias must match the alias generated by the field alias code
        //       in the code library.
        let mappings: String = self
            .map { "\($0.field.name.camelCase)\($0.parent.camelCase)" }
            .map { "self.\($0) = map[\"\($0)\"]" }
            .joined(separator: "\n")

        return """
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: DynamicCodingKeys.self)

            var map = HashMap()
            for codingKey in container.allKeys {
                if codingKey.isTypenameKey { continue }

                let alias = codingKey.stringValue
                let field = GraphQLField.getFieldNameFromAlias(alias)

                switch field {
                \(decoders)
                default:
                    throw DecodingError.dataCorrupted(
                        DecodingError.Context(
                            codingPath: decoder.codingPath,
                            debugDescription: "Unknown key \\(field)."
                        )
                    )
                }
            }

            \(includeTypenameDecoder ? #"self.__typename = try container.decode(TypeName.self, forKey: DynamicCodingKeys(stringValue: "__typename")!)"# : "")

            \(mappings)
        }
        """
    }
}

private extension Collection where Element == ObjectTypeRef {
    
    /// Returns an enumerator that we use to decode typename field.
    func typenamesEnum() -> String {
        let types = self
            .map { "case \($0.name.camelCase.normalize) = \"\($0.name)\"" }
            .joined(separator: "\n")

        return """
        enum TypeName: String, Codable {
        \(types)
        }
        """
    }
}

private extension Field {
    
    /// Returns a code that we use to decode a field in the response.
    func decoder(parent: String, context: Context) throws -> String {
        let type = try self.type.namedType.type(scalars: context.scalars)
        let wrappedType = self.type.nullable.type(for: type)

        return """
        case \"\(name.camelCase)\(parent.camelCase)\":
            if let value = try container.decode(\(wrappedType).self, forKey: codingKey) {
                map.set(key: field, hash: alias, value: value as Any)
            }
        """
    }
}

extension OutputRef {
    
    /// Returns an internal reference to the given output type ref.
    func type(scalars: ScalarMap) throws -> String {
        switch self {
        case let .scalar(scalar):
            return try scalars.scalar(scalar)
        case let .enum(enm):
            return "Enums.\(enm.pascalCase)"
        case let .object(type):
            return "Objects.\(type.pascalCase)"
        case let .interface(type):
            return "Interfaces.\(type.pascalCase)"
        case let .union(type):
            return "Unions.\(type.pascalCase)"
        }
    }
}
